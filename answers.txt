1) Как описать процесс распространения событий в JavaScript (Event Propagation)?
Основные фазы. Практическое применение знаний о фазах.

Событие в DOM проходит три основных фазы:

1. Capturing (фаза перехвата) — событие идёт сверху вниз по дереву DOM: window → document → html → body → ... → target.
2. Target (целевая фаза) — событие достигает целевого элемента (там выполняются слушатели, добавленные и на capture, и на bubble).
3. Bubbling (всплытие) — событие идёт снизу вверх: target → parent → ... → document → window. Это фаза по умолчанию для большинства событий.

Ключевые детали:

* event.target — исходный элемент, где произошло действие.
* event.currentTarget — элемент, на котором сейчас выполняется обработчик.
* event.stopPropagation() — останавливает дальнейшее распространение (и capture, и bubble для последующих слушателей).
* event.stopImmediatePropagation() — ещё и предотвращает выполнение других слушателей на том же элементе.
* addEventListener(type, handler, { capture: true }) — регистрирует слушатель на фазе capture.
* в Shadow DOM события могут быть composed / composedPath() — важно при Web Components.

Практическое применение:

- Event delegation (делегирование) — назначаешь один слушатель на родительском элементе (часто ul или document) и
обрабатываешь клики по потомкам через event.target. Экономит память и упрощает динамику.

    list.addEventListener('click', (e) => {
      const btn = (e.target as HTMLElement).closest('button.item-edit');
      if (btn) { /* обработать */ }
    });

- Использование capture — полезно, если нужно перехватить событие до того, как дочерние обработчики что-то сделают
(например, для валидации или глобальной логики).

- Остановка распространения — когда нужно предотвратить «двойную» обработку
(например, внутри кнопки есть вложенный элемент с собственным обработчиком, а внешний listener не должен срабатывать).

- Passiveness: addEventListener('touchstart', fn, { passive: true }) — улучшает производительность скролла,
запрещая preventDefault() в хэндлере.

- Оптимизация: объединяй обработчики, используй 'once:true' если нужен один вызов.
----------------------------------------------------------------------------------------------------------------------
2) Promise: что это, как работает, состояния. Другие способы асинхронности. Роль Event Loop.

Promise — это объект, который представляет результат асинхронной операции, которая может завершиться успешно или с
ошибкой. Promise инкапсулирует «обещание» вернуть значение в будущем и даёт API .then(), .catch(), .finally() для работы с результатом.

Состояния Promise
- pending — ожидание (начальное состояние).
- fulfilled (или resolved) — успешно выполнен, есть значение.
- rejected — операция завершилась ошибкой.

примерчик:
      const p = new Promise<number>((resolve, reject) => {
        setTimeout(() => resolve(42), 500);
      });

      p.then(val => console.log(val)).catch(err => console.error(err));


Альтернативы обработке асинхронного кода
- Callbacks (коллбеки) — старый подход, но ведёт к «callback hell».
- async/await — синтаксический сахар над промисами; пишет код линейно:
      async function foo() {
        try {
          const val = await fetchData();
       } catch(e) {}
      }

- Observables (RxJS) — для потоков данных (множественных значений во времени), удобны для отмены, сложных трансформаций.
- Event-driven — события (EventEmitter, DOM Events) для реактивных сценариев.
- Web Workers — для выполнения тяжёлой работы вне основного потока.

Роль Event Loop
- JS — однопоточный. Event Loop управляет выполнением синхронного кода, микротасков и макротасков.
- Микротаски: результаты промисов (.then) попадают в очередь microtask и выполняются сразу после завершения текущего call stack, до следующего рендера и до макротасков.
- Макротаски: setTimeout, setInterval, I/O, UI events — обрабатываются после микротасков.
- Последовательность: выполняется текущий стек → выполняются все микротаски → страница может отрисоваться → выполняется следующий макротаск.

порядок вывода:

      console.log('start');
      setTimeout(()=> console.log('timeout'), 0);
      Promise.resolve().then(()=> console.log('promise'));
      console.log('end');
      // Вывод: start, end, promise, timeout


Правильная обработка ошибок (.catch или try/catch с await) — чтобы избежать unhandled promise rejections.
Знание порядка (microtask vs macrotask) важно при создании UI-эффектов, debounce/Throttle и при тестировании.
-----------------------------------------------------------------------------------------------------------------------
3) Что такое ООП и как реализовано в JavaScript. Ключевые принципы с примерами.

ООП (Object-Oriented Programming) — парадигма, где данные и поведение объединены в объекты.
Ключевые принципы:
1. Инкапсуляция — скрытие внутреннего состояния объекта и предоставление интерфейса (методов) для взаимодействия.
2. Абстракция — выделение значимых свойств и методов, скрытие деталей реализации.
3. Наследование — создание новых типов на базе существующих (повторное использование кода).
4. Полиморфизм — объекты разных типов могут использовать одинаковый интерфейс (методы), поведение зависит от реализации.

Как это в JS (особенности)
* JS — прототипно-ориентированный язык. Наследование происходит через цепочку прототипов ([[Prototype]]).
* В современных версиях есть синтаксис class, но это синтаксический сахар поверх прототипов.

---Примеры:

*-* Класс и наследование (ES6):

      class Animal {
        constructor(public name) {}
       speak() { console.log(`${this.name} издает звук`); }
      }

      class Dog extends Animal {
        speak() { console.log(`${this.name} гав!`); } // полиморфизм (override)
      }

      const d = new Dog('Боб');
      d.speak(); // "Боб гав!"

*-* Прототипы прямо:

      function Person(name) {
        this.name = name;
      }
      Person.prototype.greet = function() { console.log('Hi ' + this.name); };

      const p = new Person('Ira');
      p.greet();

*-* Инкапсуляция — приватные поля (ES2022):

      class Counter {
        #count = 0; // приватное поле
        inc() { this.#count++; }
        get value() { return this.#count; }
      }


*-* Полиморфизм через интерфейс (duck typing):

      function draw(shape) {
       shape.draw(); // любой объект с методом draw() подойдёт
      }


/*/ Методы на prototype экономят память (все экземпляры разделяют одну функцию).
/*/ 'this' — динамическое; осторожно с методами как callback (нужно bind или стрелочные функции не подходит как метод,
потому что у стрелочной функции this лексический).
/*/ Часто вместо глубокого наследования рекомендуется композиция (has-a) и утилиты/mixins.
-------------------------------------------------------------------------------------------------------------
4) Как браузер обрабатывает URL — от ввода до отображения. Оптимизации и потенциальные проблемы безопасности/междоменность.

Ниже последовательность шагов, что происходит когда в адресной строке введён URL и нажата на Enter:

1. Проверки локального кэша/Service Worker

  * Браузер может проверять Service Worker, HTTP-кэш / Service Worker может перехватывать данные и отвечать на них.

2. DNS lookup

  * Браузер получает IP по домену (может быть кэш, hosts, OS resolver).
  * Оптимизация: DNS prefetch, preconnect.

3. Установка соединения

  * TCP handshake (3-way) → TLS handshake (если HTTPS). Для HTTP/3 используется QUIC (быстрее).
  * Оптимизации: TCP/TLS session resumption, keep-alive, HTTP/2/3 multiplexing, preconnect.

4. HTTP(S) Request

  * Browser отправляет GET/POST со заголовками (Accept, Cookie, User-Agent и т.д.).
  * Сервер отвечает статусом (200, 301, 304, 4xx, 5xx). Redirect может изменить URL.

5. Получение ответа и его обработка

  * Если Content-Type: text/html — парсится HTML. Если 304 Not Modified — берётся из кэша.
  * Серверные заголовки кэширования (Cache-Control, ETag, Expires) управляют повторными запросами.

6. Парсинг HTML, построение DOM

  * Парсер создаёт дерево DOM по мере получения HTML (streaming parsing — incremental render).
  * Когда встречается <link rel="stylesheet">, CSS загружается и парсится -> строится CSSOM. CSS блокирует визуальный рендер, поэтому важен критический CSS.
  * Когда встречается <script> без async/defer, парсер останавливается, скрипт загружается и выполняется — может модифицировать DOM.

7. Построение Render Tree (используя DOM + CSSOM)

  * Создаётся дерево визуальных объектов без скрытых элементов.
  * Layout (reflow) — вычисление размеров/позиций.
  * Paint — отрисовка пикселей.
  * Composite — объединение слоёв GPU.

8. Загрузка дополнительных ресурсов

  * Изображения, шрифты, скрипты, XHR/fetch, и т.д. — браузер делает параллельные запросы (в зависимости от HTTP/1.1 vs HTTP/2 limits).

9. Интерактивность

  * После загрузки и выполнения JS приложение становится интерактивным. Первый meaningful paint/First Contentful Paint (FCP) и Time to Interactive (TTI) — важные метрики.

Оптимизации:
- Сократить критический путь: минимизировать и инлайнить критический CSS, откладывать неважные скрипты (defer/async).
- HTTP/2 или HTTP/3: мультиплексирование запросов, меньше латентности.
- Кэширование: правильные Cache-Control, ETag для статики + CDN.
- Preconnect / dns-prefetch / preload: заранее устанавливать соединения и приоритеты загрузки (шрифты, важные ресурсы).
- Оптимизация изображений: srcset, sizes, WebP/AVIF, lazy-loading (loading="lazy").
- HTTP compression: gzip, brotli.
- Минимизировать main-thread work: уменьшать JS, code-splitting, web-workers.
- Service Workers / SSG / SSR: SSR (server-side rendering) даёт быстрый первый рендер; SSG и CDN ускоряют выдачу.

Проблемы безопасности и междоменного взаимодействия:
- CORS (Cross-Origin Resource Sharing) — ограничивает доступ JS к ресурсам с других доменов; сервер должен выставить правильные заголовки (Access-Control-Allow-Origin).
- SOP (Same Origin Policy) — блокирует доступ между разными источниками (протокол+домен+порт).
- Mixed content — загрузка HTTP-ресурсов из HTTPS-страницы может быть блокирована.
- CSRF / XSS — межсайтовые атаки; CSP (Content-Security-Policy) и правильная обработка вводимых данных уменьшают риск.
- Cookies: SameSite, Secure, HttpOnly — важные атрибуты для безопасности.
- CSP, X-Frame-Options, HSTS — помогают предотвращать iframe-атаки, подмену сертификатов, и заставляют HTTPS.
- Certificates / TLS: проблемы с просроченными сертификатами или некорректной цепочкой приведут к ошибкам загрузки.
- Сведения о пользователе и приватность: Referrer policy, доверенные источники, ограничение доступа к API.
